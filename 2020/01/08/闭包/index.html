<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>闭包 | 青羽凉的Blog</title>
    <meta name="description" content="这是一个利用vuepress搭建的博客项目">


    <link rel="preload" href="/wy_vuepress_blog/assets/css/0.styles.67037bd5.css" as="style"><link rel="preload" href="/wy_vuepress_blog/assets/js/app.c1b2be7e.js" as="script"><link rel="preload" href="/wy_vuepress_blog/assets/js/4.b3397e3d.js" as="script"><link rel="preload" href="/wy_vuepress_blog/assets/js/5.026990a3.js" as="script"><link rel="preload" href="/wy_vuepress_blog/assets/js/18.b821c70e.js" as="script"><link rel="prefetch" href="/wy_vuepress_blog/assets/js/1.72ff1fc8.js"><link rel="prefetch" href="/wy_vuepress_blog/assets/js/10.6ecc2235.js"><link rel="prefetch" href="/wy_vuepress_blog/assets/js/11.0d07af16.js"><link rel="prefetch" href="/wy_vuepress_blog/assets/js/12.defd96bb.js"><link rel="prefetch" href="/wy_vuepress_blog/assets/js/13.e33a3799.js"><link rel="prefetch" href="/wy_vuepress_blog/assets/js/14.63859b5a.js"><link rel="prefetch" href="/wy_vuepress_blog/assets/js/15.718068fe.js"><link rel="prefetch" href="/wy_vuepress_blog/assets/js/16.80c2e10c.js"><link rel="prefetch" href="/wy_vuepress_blog/assets/js/17.8ceb57bf.js"><link rel="prefetch" href="/wy_vuepress_blog/assets/js/19.1cb6a347.js"><link rel="prefetch" href="/wy_vuepress_blog/assets/js/6.c0716e11.js"><link rel="prefetch" href="/wy_vuepress_blog/assets/js/7.99023b5a.js"><link rel="prefetch" href="/wy_vuepress_blog/assets/js/8.3faa29b9.js"><link rel="prefetch" href="/wy_vuepress_blog/assets/js/9.84990051.js"><link rel="prefetch" href="/wy_vuepress_blog/assets/js/vuejs-paginate.d53f7e69.js">
    <link rel="stylesheet" href="/wy_vuepress_blog/assets/css/0.styles.67037bd5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuperess-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/wy_vuepress_blog/" class="nav-link home-link">青羽凉的Blog </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/wy_vuepress_blog/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/wy_vuepress_blog/tag/" class="nav-link">Tags</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/wy_vuepress_blog/" class="nav-link mobile-home-link">青羽凉的Blog </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/wy_vuepress_blog/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/wy_vuepress_blog/tag/" class="nav-link">Tags</a></li></ul></div></div></div> <div class="content-wrapper"><div id="vuperess-theme-blog__post-layout"><div class="vuepress-blog-theme-content"><div class="content__default"><h1 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h1> <p>我们首先通过一个面试中常被问到的问题进行函数：</p> <h2 id="一、闭包会造成内存泄漏吗？"><a href="#一、闭包会造成内存泄漏吗？" class="header-anchor">#</a> 一、闭包会造成内存泄漏吗？</h2> <p>我们先给这个问题下一个结论：
闭包是不会造成内存泄漏的！</p> <h3 id="_1、什么是内存泄漏"><a href="#_1、什么是内存泄漏" class="header-anchor">#</a> 1、什么是内存泄漏</h3> <p>内存泄漏就是程序中以动态分配的堆内存，在长期引用中未得到释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢，或导致系统崩溃等严重的后果。</p> <p>通俗来说，就是程序长期持有一块内存引用，且得不到释放。</p> <h3 id="_2、什么是闭包"><a href="#_2、什么是闭包" class="header-anchor">#</a> 2、什么是闭包</h3> <p>闭包是函数和声明该函数的词法环境的组合。它是一种函数，但与普通函数最大的区别就是，它绑定了执行环境。</p> <p>js中，闭包是绑定了执行环境的函数，这是与普通函数最大的区别。</p> <h3 id="_3、什么是执行环境"><a href="#_3、什么是执行环境" class="header-anchor">#</a> 3、什么是执行环境</h3> <p>执行环境有下列三个明显的特点：
1、函数的词法环境，包括this和函数的作用域链
2、标识符的列表，指的是函数用到但未声明的变量
3、表达式部分，指的是函数体</p> <p>举个栗子：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上述例子定义一个函数fn，如果在函数体中打印一个未声明的变量a，那么这时函数就会通过作用域链的方式，向上查找，最终查到到window。如果window对象中也没有定义变量a，那就会打印undefined。</p> <p>这个函数符合了执行环境的三个特点。函数的词法环境中，this指向window；标识符的列表，有未声明的变量a；表达式部分就是函数体本身。但这个却不是闭包，它只是闭包的现象。</p> <p>为什么呢？因为闭包的本质是<strong>通过闭包的方式</strong>向上查找使用但未声明的变量，而上述函数的本质还是通过<strong>作用域链</strong>的形式去查找。</p> <p>我们继续看另外一个栗子：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span>；
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre></div><p>这里定义了一个函数fn，fn返回了另外一个带有执行环境的匿名函数。同时，在匿名函数内部调用了未声明的变量a，此时函数向上查找fn中是否有定义变量a，但不是通过作用域链的方式查找，而是通过闭包的方式。</p> <p>这匿名函数就是一个闭包，在创建的时候携带执行环境，并包含词法环境、标识符列表和表达式部分。</p> <p>再看一个栗子：</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">3</span>；
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
</code></pre></div><p>这时候fn内部并没有声明变量a，并赋值为2了。那a依旧会先沿着闭包的方式往上查找，查找到fn中并没有a这个属性，然后又会以作用域链的方式往上层查找，这时候的a会被当时window对象下的属性a，所以最终打印结果就是3。</p> <p>到这里，你是不是就明白了，闭包和内存泄漏其实没什么关联了。</p> <h2 id="二、为什么会造成内存泄漏？"><a href="#二、为什么会造成内存泄漏？" class="header-anchor">#</a> 二、为什么会造成内存泄漏？</h2> <p>其实，内存泄漏的起源是ie浏览器，属于早期ie浏览器的一个bug。原因是早期的ie浏览器采用一个名为“引用计数策略”的垃圾回收机制。我们先通过代码理解下什么是“引用计数策略”？</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//计数1</span>
<span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 计数1</span>
o<span class="token punctuation">.</span>a <span class="token operator">=</span> o2<span class="token punctuation">;</span>
o2<span class="token punctuation">.</span>a <span class="token operator">=</span> o<span class="token punctuation">;</span>
</code></pre></div><p>上述栗子中。定义了对象o和o2，然后给o扩展一个属性a，并赋值o2，给o2扩展一个属性a，并赋值o。这样o对象在“引用计数策略”中就会被计数为1，o2也是如此。</p> <p>只要对象被引用，内存中的计数就会一直保持着。这样就会导致内存泄漏。而上述代码内存泄漏的根源，就是对象的循环引用，这恰恰是“引用计数策略”无法解决的问题。</p> <p>如何避免这种情况呢？</p> <p>其实很简单，就是在无需使用时，手动重置为null。</p> <div class="language-JavaScript extra-class"><pre class="language-javascript"><code>o<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
o2<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre></div><p>但是，我们是无法确保每个程序开发者都有这样一个良好的编程习惯的，尤其是在使用闭包的时候，内存泄漏尤为严重。所以ie浏览器就采用了另外一种算法，“标记+清除垃圾回收算法”作为垃圾回收机制。</p> <p>该算法与“引用计数策略”的最大的不同点就是增加了root根对象。每隔一段时间，就会去查找root根对象中被标记计数的对象是否能被访问到，如访问不到，则该块内存就会被回收。</p> <p>举例：</p> <div class="language-JavaScirpt extra-class"><pre class="language-text"><code>function fn() {
  var o = {};
  var o2 = {};
  o.a = o2;
  o2.a = o;
}
fn()
</code></pre></div><p>虽然在fn函数内部也一样使用了循环调用，但程序最外层的root根对象，我们可以理解为window，它是查找不到o和o2的，那就会被释放。</p> <p>按照我们上面的说法，其实还有另外一种情况。就是程序编写时，这种循环引用不写在函数内部，那内存泄漏就无法避免了。因为，内存泄漏说到底，就是<strong>一些额外的、或者是可避免的花销或内存占用</strong>。</p> <p>也就是说，如果我们在全局定义了很多全局变量，只要这些全局变量不属于额外的花销，那就不属于内存泄漏。当然，全局变量还是尽量精简，道理大家都明白。</p></div> <!----> <hr> <!----></div> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#一、闭包会造成内存泄漏吗？" title="一、闭包会造成内存泄漏吗？">一、闭包会造成内存泄漏吗？</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_1、什么是内存泄漏" title="1、什么是内存泄漏">1、什么是内存泄漏</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_2、什么是闭包" title="2、什么是闭包">2、什么是闭包</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#_3、什么是执行环境" title="3、什么是执行环境">3、什么是执行环境</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#二、为什么会造成内存泄漏？" title="二、为什么会造成内存泄漏？">二、为什么会造成内存泄漏？</a></div></div></div></div> <footer class="footer" data-v-97b6647a><div class="footer-left-wrap" data-v-97b6647a><ul class="contact" data-v-97b6647a><li class="contact-item" data-v-97b6647a><a href="https://github.com/xtt55" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-97b6647a><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-97b6647a><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-97b6647a></path></svg>

        </a></li></ul></div> <div class="footer-right-wrap" data-v-97b6647a><ul class="copyright" data-v-97b6647a><li class="copyright-item" data-v-97b6647a><a href="/wy_vuepress_blog/2020/01/08/%E9%97%AD%E5%8C%85/.html" class="nav-link" data-v-97b6647a>MIT Licensed | Copyright © 2020-present 青羽凉</a></li></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/wy_vuepress_blog/assets/js/app.c1b2be7e.js" defer></script><script src="/wy_vuepress_blog/assets/js/4.b3397e3d.js" defer></script><script src="/wy_vuepress_blog/assets/js/5.026990a3.js" defer></script><script src="/wy_vuepress_blog/assets/js/18.b821c70e.js" defer></script>
  </body>
</html>
