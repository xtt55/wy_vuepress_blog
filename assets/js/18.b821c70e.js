(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{280:function(t,a,s){"use strict";s.r(a);var n=s(4),r=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),s("p",[t._v("我们首先通过一个面试中常被问到的问题进行函数：")]),t._v(" "),s("h2",{attrs:{id:"一、闭包会造成内存泄漏吗？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、闭包会造成内存泄漏吗？"}},[t._v("#")]),t._v(" 一、闭包会造成内存泄漏吗？")]),t._v(" "),s("p",[t._v("我们先给这个问题下一个结论：\n闭包是不会造成内存泄漏的！")]),t._v(" "),s("h3",{attrs:{id:"_1、什么是内存泄漏"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、什么是内存泄漏"}},[t._v("#")]),t._v(" 1、什么是内存泄漏")]),t._v(" "),s("p",[t._v("内存泄漏就是程序中以动态分配的堆内存，在长期引用中未得到释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢，或导致系统崩溃等严重的后果。")]),t._v(" "),s("p",[t._v("通俗来说，就是程序长期持有一块内存引用，且得不到释放。")]),t._v(" "),s("h3",{attrs:{id:"_2、什么是闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、什么是闭包"}},[t._v("#")]),t._v(" 2、什么是闭包")]),t._v(" "),s("p",[t._v("闭包是函数和声明该函数的词法环境的组合。它是一种函数，但与普通函数最大的区别就是，它绑定了执行环境。")]),t._v(" "),s("p",[t._v("js中，闭包是绑定了执行环境的函数，这是与普通函数最大的区别。")]),t._v(" "),s("h3",{attrs:{id:"_3、什么是执行环境"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、什么是执行环境"}},[t._v("#")]),t._v(" 3、什么是执行环境")]),t._v(" "),s("p",[t._v("执行环境有下列三个明显的特点：\n1、函数的词法环境，包括this和函数的作用域链\n2、标识符的列表，指的是函数用到但未声明的变量\n3、表达式部分，指的是函数体")]),t._v(" "),s("p",[t._v("举个栗子：")]),t._v(" "),s("div",{staticClass:"language-JavaScript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("上述例子定义一个函数fn，如果在函数体中打印一个未声明的变量a，那么这时函数就会通过作用域链的方式，向上查找，最终查到到window。如果window对象中也没有定义变量a，那就会打印undefined。")]),t._v(" "),s("p",[t._v("这个函数符合了执行环境的三个特点。函数的词法环境中，this指向window；标识符的列表，有未声明的变量a；表达式部分就是函数体本身。但这个却不是闭包，它只是闭包的现象。")]),t._v(" "),s("p",[t._v("为什么呢？因为闭包的本质是"),s("strong",[t._v("通过闭包的方式")]),t._v("向上查找使用但未声明的变量，而上述函数的本质还是通过"),s("strong",[t._v("作用域链")]),t._v("的形式去查找。")]),t._v(" "),s("p",[t._v("我们继续看另外一个栗子：")]),t._v(" "),s("div",{staticClass:"language-JavaScript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("；\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2")]),t._v("\n")])])]),s("p",[t._v("这里定义了一个函数fn，fn返回了另外一个带有执行环境的匿名函数。同时，在匿名函数内部调用了未声明的变量a，此时函数向上查找fn中是否有定义变量a，但不是通过作用域链的方式查找，而是通过闭包的方式。")]),t._v(" "),s("p",[t._v("这匿名函数就是一个闭包，在创建的时候携带执行环境，并包含词法环境、标识符列表和表达式部分。")]),t._v(" "),s("p",[t._v("再看一个栗子：")]),t._v(" "),s("div",{staticClass:"language-JavaScript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("；\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 3")]),t._v("\n")])])]),s("p",[t._v("这时候fn内部并没有声明变量a，并赋值为2了。那a依旧会先沿着闭包的方式往上查找，查找到fn中并没有a这个属性，然后又会以作用域链的方式往上层查找，这时候的a会被当时window对象下的属性a，所以最终打印结果就是3。")]),t._v(" "),s("p",[t._v("到这里，你是不是就明白了，闭包和内存泄漏其实没什么关联了。")]),t._v(" "),s("h2",{attrs:{id:"二、为什么会造成内存泄漏？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、为什么会造成内存泄漏？"}},[t._v("#")]),t._v(" 二、为什么会造成内存泄漏？")]),t._v(" "),s("p",[t._v("其实，内存泄漏的起源是ie浏览器，属于早期ie浏览器的一个bug。原因是早期的ie浏览器采用一个名为“引用计数策略”的垃圾回收机制。我们先通过代码理解下什么是“引用计数策略”？")]),t._v(" "),s("div",{staticClass:"language-JavaScript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" o "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//计数1")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" o2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 计数1")]),t._v("\no"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" o2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\no2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("上述栗子中。定义了对象o和o2，然后给o扩展一个属性a，并赋值o2，给o2扩展一个属性a，并赋值o。这样o对象在“引用计数策略”中就会被计数为1，o2也是如此。")]),t._v(" "),s("p",[t._v("只要对象被引用，内存中的计数就会一直保持着。这样就会导致内存泄漏。而上述代码内存泄漏的根源，就是对象的循环引用，这恰恰是“引用计数策略”无法解决的问题。")]),t._v(" "),s("p",[t._v("如何避免这种情况呢？")]),t._v(" "),s("p",[t._v("其实很简单，就是在无需使用时，手动重置为null。")]),t._v(" "),s("div",{staticClass:"language-JavaScript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[t._v("o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\no2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("但是，我们是无法确保每个程序开发者都有这样一个良好的编程习惯的，尤其是在使用闭包的时候，内存泄漏尤为严重。所以ie浏览器就采用了另外一种算法，“标记+清除垃圾回收算法”作为垃圾回收机制。")]),t._v(" "),s("p",[t._v("该算法与“引用计数策略”的最大的不同点就是增加了root根对象。每隔一段时间，就会去查找root根对象中被标记计数的对象是否能被访问到，如访问不到，则该块内存就会被回收。")]),t._v(" "),s("p",[t._v("举例：")]),t._v(" "),s("div",{staticClass:"language-JavaScirpt extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("function fn() {\n  var o = {};\n  var o2 = {};\n  o.a = o2;\n  o2.a = o;\n}\nfn()\n")])])]),s("p",[t._v("虽然在fn函数内部也一样使用了循环调用，但程序最外层的root根对象，我们可以理解为window，它是查找不到o和o2的，那就会被释放。")]),t._v(" "),s("p",[t._v("按照我们上面的说法，其实还有另外一种情况。就是程序编写时，这种循环引用不写在函数内部，那内存泄漏就无法避免了。因为，内存泄漏说到底，就是"),s("strong",[t._v("一些额外的、或者是可避免的花销或内存占用")]),t._v("。")]),t._v(" "),s("p",[t._v("也就是说，如果我们在全局定义了很多全局变量，只要这些全局变量不属于额外的花销，那就不属于内存泄漏。当然，全局变量还是尽量精简，道理大家都明白。")])])}),[],!1,null,null,null);a.default=r.exports}}]);